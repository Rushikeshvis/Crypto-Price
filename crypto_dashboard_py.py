# -*- coding: utf-8 -*-
"""crypto_dashboard.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q9rHsZcXIm88FfIDcSKXlQ5yI6s79o3q
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta

# --- Page Configuration ---
# Set page config for a wide layout, dark theme, and a fitting title.
st.set_page_config(
    page_title="Crypto Analysis Dashboard",
    page_icon="ðŸ’¸",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- Custom CSS for "Masterpiece" Look ---
def load_css():
    """Applies custom CSS for a professional, dark-themed look."""
    st.markdown("""
    <style>
        /* Base app background */
        .stApp {
            background-color: #0E1117;
            color: #FAFAFA;
        }

        /* Sidebar styling */
        .css-1d391kg {
            background-color: #1a1e29;
            border-right: 1px solid #2a2e3d;
        }

        /* Metric card styling */
        .css-1r6slb0, .css-1v0mbdj {
            background-color: #1a1e29;
            border: 1px solid #2a2e3d;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Metric label */
        .css-1avcm0n {
            font-size: 16px;
            color: #a0a0a0;
        }

        /* Metric value */
        .css-q8sbsg {
            font-size: 28px;
            font-weight: 600;
        }

        /* Headers */
        h1, h2, h3 {
            color: #FAFAFA;
        }

        /* Plotly chart background */
        .js-plotly-plot .plotly .bg {
            fill: #1a1e29 !important;
        }

        /* Expander styling */
        .st-expander {
            background-color: #1a1e29;
            border-radius: 10px;
            border: 1px solid #2a2e3d;
        }
        .st-expander header {
            color: #FAFAFA;
            font-weight: 600;
        }
    </style>
    """, unsafe_allow_html=True)

# --- Data Loading and Generation ---

@st.cache_data
def get_coin_descriptions():
    """
    Returns the dictionary of coin descriptions from the notebook.
    This is "new data" extracted from your notebook's markdown.
    """
    return {
        '1INCHUSDT': '1inch is a decentralized exchange aggregator that sources liquidity from various decentralized exchanges.',
        'AAVEUSDT': 'Aave is a decentralized finance (DeFi) protocol that enables users to lend and borrow a diverse range of cryptocurrencies.',
        'ADAUSDT': 'Cardano is a blockchain platform that aims to provide a more secure and scalable infrastructure for the development of decentralized applications and smart contracts.',
        'ALGOUSDT': 'Algorand is a blockchain platform that focuses on speed and scalability, aiming to support a wide range of decentralized applications.',
        'ATOMUSDT': 'Cosmos is a decentralized network of independent blockchains that can scale and interoperate with each other.',
        'AVAXUSDT': 'Avalanche is a platform for building decentralized applications and custom blockchain networks.',
        'BALUSDT': 'Balancer is an automated portfolio manager and decentralized exchange.',
        'BTCUSDT': 'Bitcoin is a decentralized digital currency, without a central bank or single administrator, that can be sent from user to user on the peer-to-peer bitcoin network.',
        'ETHUSDT': 'Ethereum is a decentralized, open-source blockchain with smart contract functionality. Ether is the native cryptocurrency of the platform.',
        'SOLUSDT': 'Solana is a high-performance blockchain supporting builders around the world creating crypto apps that scale today.'
    }

@st.cache_data
def load_real_data():
    """
    Loads the real cryptocurrency data from the provided CSV file.
    """
    try:
        df = pd.read_csv('crypto_data.csv', parse_dates=['date'])

        # Rename columns to match the names used in the app's logic
        df.rename(columns={
            'tradecount': 'num_trades',
            'volume usdt': 'volume'
        }, inplace=True)

        # Drop 'token' column if it exists, as 'symbol' is used
        if 'token' in df.columns:
            df = df.drop(columns=['token'])

        return df
    except FileNotFoundError:
        st.error("Error: 'crypto_data.csv' not found. Please make sure the file is in the same directory.")
        return pd.DataFrame()
    except Exception as e:
        st.error(f"Error loading data: {e}")
        return pd.DataFrame()


def preprocess_data(df):
    """
    Applies the preprocessing steps from the Jupyter Notebook.
    This function will be called on the *filtered* data for efficiency.
    """
    if df.empty:
        return pd.DataFrame()

    df_processed = df.copy()

    # Set the datetime 'date' column as the index
    # This replaces the 'open_time_dt' logic from the synthetic data
    df_processed.set_index('date', inplace=True)
    df_processed.index.name = 'open_time_dt' # Rename index for consistency

    # Feature Engineering
    # Re-create time features from the index for consistency
    df_processed['hour'] = df_processed.index.hour
    df_processed['day'] = df_processed.index.dayofweek # 0=Mon, 6=Sun
    df_processed['month'] = df_processed.index.month
    df_processed['year'] = df_processed.index.year
    df_processed['price_change'] = df_processed['close'] - df_processed['open']
    df_processed['volatility'] = df_processed['high'] - df_processed['low']

    return df_processed

# --- Main Application ---

# Load styling
load_css()

# Load data
coin_descriptions = get_coin_descriptions()
df_raw = load_real_data()

if df_raw.empty:
    st.stop()

# --- Sidebar ---
st.sidebar.title("ðŸ’¸ Crypto Dashboard")
st.sidebar.markdown("---")

# Get list of unique symbols
symbols = df_raw['symbol'].unique()
# Set default to a major coin
default_symbol_index = np.where(symbols == 'BTCUSDT')[0][0] if 'BTCUSDT' in symbols else 0
selected_symbol = st.sidebar.selectbox('Select Coin', symbols, index=int(default_symbol_index))

# Show coin description (new feature)
st.sidebar.info(f"**About {selected_symbol}:**\n {coin_descriptions.get(selected_symbol, 'No description available.')}")

# Date range selection
# Use the 'date' column from the real data
min_date = df_raw['date'].min().date()
max_date = df_raw['date'].max().date()

start_date = st.sidebar.date_input('Start Date', min_date, min_value=min_date, max_value=max_date)
end_date = st.sidebar.date_input('End Date', max_date, min_value=min_date, max_value=max_date)

if start_date > end_date:
    st.sidebar.error('Error: End date must fall after start date.')
    st.stop()

# --- Data Filtering ---
# Filter data based on sidebar selections using the 'date' column
df_filtered = df_raw[
    (df_raw['symbol'] == selected_symbol) &
    (df_raw['date'].dt.date >= start_date) &
    (df_raw['date'].dt.date <= end_date)
].copy()

# Preprocess the filtered data
df_processed = preprocess_data(df_filtered)

# --- Main Page ---
st.title(f"Analysis for {selected_symbol}")

if df_processed.empty:
    st.warning(f"No data available for {selected_symbol} in the selected date range.")
    st.stop()

# --- KPIs (New "Masterpiece" Feature) ---
st.subheader("Key Performance Indicators")

avg_close = df_processed['close'].mean()
total_volume = df_processed['volume'].sum()
total_trades = df_processed['num_trades'].sum()
avg_volatility = df_processed['volatility'].mean()

kpi1, kpi2, kpi3, kpi4 = st.columns(4)
kpi1.metric("Average Close Price", f"${avg_close:,.2f}")
kpi2.metric("Total Volume", f"{total_volume:,.0f}")
kpi3.metric("Total Trades", f"{total_trades:,.0f}")
kpi4.metric("Average Hourly Volatility", f"${avg_volatility:,.4f}")

st.markdown("---")

# --- Price Chart (New "Masterpiece" Feature) ---
st.subheader("Price Over Time")
fig_price = px.line(
    df_processed,
    y='close',
    title=f'{selected_symbol} Closing Price (Hourly)',
    template='plotly_dark'
)
fig_price.update_layout(
    xaxis_title='Date',
    yaxis_title='Price (USDT)',
    paper_bgcolor="#1a1e29",
    plot_bgcolor="#1a1e29",
    font_color="#FAFAFA"
)
st.plotly_chart(fig_price, use_container_width=True)

# --- Feature Distributions (from Notebook, enhanced) ---
st.subheader("Feature Distributions")
dist_col1, dist_col2 = st.columns(2)

# Closing Prices
fig_close_dist = px.histogram(
    df_processed,
    x='close',
    nbins=100,
    title='Distribution of Closing Prices',
    marginal='box',
    template='plotly_dark'
)
fig_close_dist.update_layout(paper_bgcolor="#1a1e29", plot_bgcolor="#1a1e29")
dist_col1.plotly_chart(fig_close_dist, use_container_width=True)

# Price Change
fig_change_dist = px.histogram(
    df_processed,
    x='price_change',
    nbins=100,
    title='Distribution of Price Change (Close - Open)',
    marginal='box',
    template='plotly_dark'
)
fig_change_dist.update_layout(paper_bgcolor="#1a1e29", plot_bgcolor="#1a1e29")
dist_col2.plotly_chart(fig_change_dist, use_container_width=True)

dist_col3, dist_col4 = st.columns(2)

# Volatility
fig_vol_dist = px.histogram(
    df_processed,
    x='volatility',
    nbins=100,
    title='Distribution of Volatility (High - Low)',
    marginal='box',
    template='plotly_dark'
)
fig_vol_dist.update_layout(paper_bgcolor="#1a1e29", plot_bgcolor="#1a1e29")
dist_col3.plotly_chart(fig_vol_dist, use_container_width=True)

# Number of Trades
fig_trades_dist = px.histogram(
    df_processed,
    x='num_trades',
    nbins=100,
    title='Distribution of Number of Trades',
    marginal='box',
    template='plotly_dark'
)
fig_trades_dist.update_layout(paper_bgcolor="#1a1e29", plot_bgcolor="#1a1e29")
dist_col4.plotly_chart(fig_trades_dist, use_container_width=True)

st.markdown("---")

# --- Relationships & Correlation (from Notebook, enhanced) ---
st.subheader("Relationships & Correlation")
rel_col1, rel_col2 = st.columns([1.2, 1])

# Correlation Heatmap
with rel_col1:
    st.markdown("##### Correlation Heatmap")
    # Select only numeric cols for correlation
    corr_cols = ['open', 'high', 'low', 'close', 'volume', 'num_trades', 'price_change', 'volatility', 'hour', 'day', 'month']

    # Ensure all columns exist before calculating correlation
    corr_cols_exist = [col for col in corr_cols if col in df_processed.columns]
    if len(corr_cols_exist) < len(corr_cols):
        st.warning(f"Missing columns for correlation: {set(corr_cols) - set(corr_cols_exist)}")

    corr_df = df_processed[corr_cols_exist].corr()

    fig_corr = px.imshow(
        corr_df,
        text_auto=True,
        aspect='auto',
        color_continuous_scale='RdBu_r',
        zmin=-1,
        zmax=1,
        template='plotly_dark'
    )
    fig_corr.update_layout(paper_bgcolor="#1a1e29", plot_bgcolor="#1a1e29")
    st.plotly_chart(fig_corr, use_container_width=True)

# Scatter Plots
with rel_col2:
    st.markdown("##### Scatter Plots")

    # Use tabs for a cleaner layout
    tab1, tab2 = st.tabs(["Price vs. Trades", "Price vs. Volatility"])

    with tab1:
        fig_scatter_trades = px.scatter(
            df_processed.sample(min(1000, len(df_processed))),  # Sample for performance
            x='num_trades',
            y='close',
            title='Closing Prices vs. Number of Trades',
            trendline='ols',
            trendline_color_override='red',
            template='plotly_dark'
        )
        fig_scatter_trades.update_traces(marker=dict(opacity=0.5))
        fig_scatter_trades.update_layout(paper_bgcolor="#1a1e29", plot_bgcolor="#1a1e29")
        st.plotly_chart(fig_scatter_trades, use_container_width=True)

    with tab2:
        fig_scatter_vol = px.scatter(
            df_processed.sample(min(1000, len(df_processed))), # Sample for performance
            x='volatility',
            y='close',
            title='Closing Prices vs. Volatility',
            trendline='ols',
            trendline_color_override='red',
            template='plotly_dark'
        )
        fig_scatter_vol.update_traces(marker=dict(opacity=0.5))
        fig_scatter_vol.update_layout(paper_bgcolor="#1a1e29", plot_bgcolor="#1a1e29")
        st.plotly_chart(fig_scatter_vol, use_container_width=True)

st.markdown("---")

# --- Data Explorer (from Notebook) ---
with st.expander("Explore the Data"):
    st.subheader("Processed Data (Filtered)")
    st.markdown("This is the preprocessed data for the selected coin and date range.")
    st.dataframe(df_processed)

    st.subheader("Statistical Summary (Processed Data)")
    st.dataframe(df_processed[corr_cols_exist].describe())

    st.subheader("Raw Data (All Coins)")
    st.markdown("This is the original, unprocessed data from 'crypto_data.csv'.")
    st.dataframe(df_raw.head(100))